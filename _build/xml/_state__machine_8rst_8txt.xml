<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="_state__machine_8rst_8txt" kind="file" language="C++">
    <compoundname>State_machine.rst.txt</compoundname>
      <sectiondef kind="var">
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s the knowledge base represented by** cluedo_kb** node is made to the final_oracle node through the oracle_solution service</definition>
        <argsstring></argsstring>
        <name>service</name>
        <initializer>=================================

:Authors:
    Fedehub
:Version:
    1.0

About the node 
---------------

It implements a <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> controls the operations of the robot</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="18" column="54" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="2" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible solutions or not If there occurs no possible</type>
        <definition>Code docs *State_machine py *it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into **four **states **move **→ moves the robot between rooms inside the simulated indoor environment **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible solutions</definition>
        <argsstring></argsstring>
        <name>solutions</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="18" column="168" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="18" bodyend="-1"/>
        <referencedby refid="classaruco_1_1_marker_pose_tracker_1a8eeb8ba3c29a89c7c9c20e33197b59a7" compoundref="posetracker_8cpp" startline="368" endline="395">aruco::MarkerPoseTracker::estimatePose</referencedby>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a7463cda555922b364d4d9285bc99f4e4" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref></type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is mistery_not_solvable</definition>
        <argsstring></argsstring>
        <name>mistery_not_solvable</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="18" column="193" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a5c4f7762ecc115173cd76d7536a61804" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref></type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state Otherwise</definition>
        <argsstring></argsstring>
        <name>Otherwise</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="18" column="263" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move state if there actually occurs possible the state machine makes a transition to the show</type>
        <definition>Code docs *State_machine py *it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into **four **states **move **→ moves the robot between rooms inside the simulated indoor environment **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK state</definition>
        <argsstring></argsstring>
        <name>state</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="18" column="366" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a88645ce357612100d96d5e7be1a989f9" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram jpg</definition>
        <argsstring></argsstring>
        <name>jpg</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="21" column="73" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="25" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a9b5199b4c81a0e3487465bc0a08a44ad" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets launched</definition>
        <argsstring></argsstring>
        <name>launched</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="25" column="28" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="25" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1abd37dd137fbf00923d40243939f0a8b0" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref></type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service Hence</definition>
        <argsstring></argsstring>
        <name>Hence</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="25" column="127" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="25" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture that interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref></type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service that</definition>
        <argsstring></argsstring>
        <name>that</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="26" column="80" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a6bdac697dc1f28556bb0b540e2e7d166" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly suggests</definition>
        <argsstring></argsstring>
        <name>suggests</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="26" column="108" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a76a8180e1e1e68a3988d24cc5f7c98e8" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only after</definition>
        <argsstring></argsstring>
        <name>after</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="26" column="171" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a784e647f2b3eb81ad423541600c71ddb" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only the system <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> to the CHECK where a request <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made by the aruco_marker <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> to retrieve the detected marker s the knowledge base represented by **cluedo_kb **node <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made to the final_oracle node through the oracle_solution the True <ref refid="_oracle_8rst_8txt_1acc5905728f3f1ab997990f9b4ccaa13b" kindref="member">ID</ref> gets compared and it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> <ref refid="_img__echo_8rst_8txt_1af89959d671d8edcafe6635b166adec1a" kindref="member">chosen</ref> whether to terminate the transitioning back to the MOVE <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> Why Smach For the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> were described explicitly Some of the most relevant</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s the knowledge base represented by** cluedo_kb** node is made to the final_oracle node through the oracle_solution the True ID gets compared and it is chosen whether to terminate the transitioning back to the MOVE state Why Smach For the state machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and state transitions were described explicitly Some of the most relevant aspects</definition>
        <argsstring></argsstring>
        <name>aspects</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="34" column="27" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there are possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only the system <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> to the CHECK where a request <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made by the aruco_marker <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> to retrieve the detected marker s the knowledge base represented by **cluedo_kb **node <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made to the final_oracle node through the oracle_solution the True <ref refid="_oracle_8rst_8txt_1acc5905728f3f1ab997990f9b4ccaa13b" kindref="member">ID</ref> gets compared and it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> <ref refid="_img__echo_8rst_8txt_1af89959d671d8edcafe6635b166adec1a" kindref="member">chosen</ref> whether to terminate the transitioning back to the MOVE <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> Why Smach For the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> were described explicitly Some of the most relevant offered by such a package</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s the knowledge base represented by** cluedo_kb** node is made to the final_oracle node through the oracle_solution the True ID gets compared and it is chosen whether to terminate the transitioning back to the MOVE state Why Smach For the state machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and state transitions were described explicitly Some of the most relevant offered by such a package are</definition>
        <argsstring></argsstring>
        <name>are</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="34" column="61" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1af11e9ac7d4e83f3a1c9d027dd32ddbf1" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only the system <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> to the CHECK where a request <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made by the aruco_marker <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> to retrieve the detected marker s the knowledge base represented by **cluedo_kb **node <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made to the final_oracle node through the oracle_solution the True <ref refid="_oracle_8rst_8txt_1acc5905728f3f1ab997990f9b4ccaa13b" kindref="member">ID</ref> gets compared and it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> <ref refid="_img__echo_8rst_8txt_1af89959d671d8edcafe6635b166adec1a" kindref="member">chosen</ref> whether to terminate the transitioning back to the MOVE <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> Why Smach For the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> were described explicitly Some of the most relevant offered by such a package maintain and debug</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s the knowledge base represented by** cluedo_kb** node is made to the final_oracle node through the oracle_solution the True ID gets compared and it is chosen whether to terminate the transitioning back to the MOVE state Why Smach For the state machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and state transitions were described explicitly Some of the most relevant offered by such a package maintain and debug large</definition>
        <argsstring></argsstring>
        <name>large</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="38" column="21" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a0a0b85e13b1280def97c39ad9cbd3466" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only the system <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> to the CHECK where a request <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made by the aruco_marker <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> to retrieve the detected marker s the knowledge base represented by **cluedo_kb **node <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made to the final_oracle node through the oracle_solution the True <ref refid="_oracle_8rst_8txt_1acc5905728f3f1ab997990f9b4ccaa13b" kindref="member">ID</ref> gets compared and it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> <ref refid="_img__echo_8rst_8txt_1af89959d671d8edcafe6635b166adec1a" kindref="member">chosen</ref> whether to terminate the transitioning back to the MOVE <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> Why Smach For the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> were described explicitly Some of the most relevant offered by such a package maintain and debug complex hierarchical <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machines You can find an example of a complex hierarchical <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine here **</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s the knowledge base represented by** cluedo_kb** node is made to the final_oracle node through the oracle_solution the True ID gets compared and it is chosen whether to terminate the transitioning back to the MOVE state Why Smach For the state machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and state transitions were described explicitly Some of the most relevant offered by such a package maintain and debug complex hierarchical state machines You can find an example of a complex hierarchical state machine here** Introspection</definition>
        <argsstring></argsstring>
        <name>Introspection</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="40" column="2" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot transitions back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made by the aruco_marker <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> to retrieve the detected marker s the knowledge base represented by **cluedo_kb **node <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made to the final_oracle node through the oracle_solution the True <ref refid="_oracle_8rst_8txt_1acc5905728f3f1ab997990f9b4ccaa13b" kindref="member">ID</ref> gets compared and it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> <ref refid="_img__echo_8rst_8txt_1af89959d671d8edcafe6635b166adec1a" kindref="member">chosen</ref> whether to terminate the transitioning back to the MOVE <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> Why Smach For the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> transitions were described explicitly Some of the most relevant offered by such a package maintain and debug complex hierarchical <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machines You can find an example of a complex hierarchical <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine here <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref></type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s the knowledge base represented by** cluedo_kb** node is made to the final_oracle node through the oracle_solution the True ID gets compared and it is chosen whether to terminate the transitioning back to the MOVE state Why Smach For the state machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and state transitions were described explicitly Some of the most relevant offered by such a package maintain and debug complex hierarchical state machines You can find an example of a complex hierarchical state machine here state transitions</definition>
        <argsstring></argsstring>
        <name>transitions</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="40" column="22" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="_state__machine_8rst_8txt_1a69249a33a341db4aa4cb8bc9b88d503a" prot="public" static="no" mutable="no">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only the system <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> to the CHECK where a request <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made by the aruco_marker <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> to retrieve the detected marker s the knowledge base represented by **cluedo_kb **node <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made to the final_oracle node through the oracle_solution the True <ref refid="_oracle_8rst_8txt_1acc5905728f3f1ab997990f9b4ccaa13b" kindref="member">ID</ref> gets compared and it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> <ref refid="_img__echo_8rst_8txt_1af89959d671d8edcafe6635b166adec1a" kindref="member">chosen</ref> whether to terminate the transitioning back to the MOVE <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> Why Smach For the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> were described explicitly Some of the most relevant offered by such a package maintain and debug complex hierarchical <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machines You can find an example of a complex hierarchical <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine here <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> data</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s the knowledge base represented by** cluedo_kb** node is made to the final_oracle node through the oracle_solution the True ID gets compared and it is chosen whether to terminate the transitioning back to the MOVE state Why Smach For the state machine SMACH has been employed since it was needed a robot capable of achieving a Plan where all possible states and state transitions were described explicitly Some of the most relevant offered by such a package maintain and debug complex hierarchical state machines You can find an example of a complex hierarchical state machine here state data flow</definition>
        <argsstring></argsstring>
        <name>flow</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="40" column="39" bodyfile="_build/html/_sources/code_documentation/State_machine.rst.txt" bodystart="40" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="_state__machine_8rst_8txt_1ad09e3d9cbc01b152c2c1311a5a5950f0" prot="public" static="no" const="no" explicit="no" inline="no" new="yes" virt="non-virtual">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only the system <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> to the CHECK where a request <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made by the aruco_marker <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> to retrieve the detected marker s</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s IDs</definition>
        <argsstring>(by means of a topic subscription). Whenever a new hint gets detected</argsstring>
        <name>IDs</name>
        <param>
          <type>by means of a topic</type>
          <declname>subscription</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="26" column="304"/>
      </memberdef>
      <memberdef kind="function" id="_state__machine_8rst_8txt_1a2659887f46d0b471a57b5e07c4be95e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the <ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref> into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only the system <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> to the CHECK where a request <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made by the aruco_marker <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> to retrieve the detected marker s the knowledge base represented by **cluedo_kb **node <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref></type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s the knowledge base represented by** cluedo_kb** node is issued</definition>
        <argsstring>(with a ``/oracle_hint`` service request). By means of a further request</argsstring>
        <name>issued</name>
        <param>
          <type>with a ``/oracle_hint`` <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref></type>
          <declname>request</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="27" column="62"/>
      </memberdef>
      <memberdef kind="function" id="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Code docs *State_machine py *it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> the core node of the architecture <ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref> interacts with and directs all remaining parts In <ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref> the machine organises the investigation into **four **states **move **→ moves the robot between <ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref> inside the simulated indoor <ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref> **collect **→ the robot rotates on itself to read the largest number of hints within the room **check **→ takes hints from the sensing system via a and uses the ontology to work out whether there <ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref> possible <ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref> or not If there occurs no possible the outcome <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> and the robot <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> back to the move <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> if there actually occurs possible the <ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref> machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness **show **→ questions the oracle about the solution image::ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> as the name explicitly makes detectibot turning around its own position Only the system <ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref> to the CHECK where a request <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made by the aruco_marker <ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref> to retrieve the detected marker s the knowledge base represented by **cluedo_kb **node <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> made to the final_oracle node through the oracle_solution the True <ref refid="_oracle_8rst_8txt_1acc5905728f3f1ab997990f9b4ccaa13b" kindref="member">ID</ref> gets compared and it <ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref> <ref refid="_img__echo_8rst_8txt_1af89959d671d8edcafe6635b166adec1a" kindref="member">chosen</ref> whether to terminate the</type>
        <definition>Code docs* State_machine py* it is the core node of the architecture that interacts with and directs all remaining parts In particular the machine organises the investigation into** four** states** move** → moves the robot between rooms inside the simulated indoor environment** collect** → the robot rotates on itself to read the largest number of hints within the room** check** → takes hints from the sensing system via a and uses the ontology to work out whether there are possible solutions or not If there occurs no possible the outcome is and the robot transitions back to the move state if there actually occurs possible the state machine makes a transition to the show responsible for querying the oracle about the solution s truthfulness** show** → questions the oracle about the solution image:: ExperimentalRoboticsAssignment3 media state_diagrams state_diagram as the state_machine gets the robot enters the MOVE responsible for the acrivation of the go_to_point service it reaches the center of the room and it starts to collect as many marker as possible This has been made possible through the implementation of a turn_robot service as the name explicitly makes detectibot turning around its own position Only the system transitions to the CHECK where a request is made by the aruco_marker service to retrieve the detected marker s the knowledge base represented by** cluedo_kb** node is made to the final_oracle node through the oracle_solution the True ID gets compared and it is chosen whether to terminate the investigation</definition>
        <argsstring>(ending up in a MISTERY_SOLVED state) or pursuing it</argsstring>
        <name>investigation</name>
        <param>
          <type>ending up in a MISTERY_SOLVED</type>
          <declname>state</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="_build/html/_sources/code_documentation/State_machine.rst.txt" line="29" column="141"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="normal">Code<sp/>docs<sp/>--<sp/>*State_machine.py*</highlight></codeline>
<codeline lineno="2" refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" refkind="member"><highlight class="normal">=================================</highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal">:Authors:</highlight></codeline>
<codeline lineno="5"><highlight class="normal"><sp/><sp/><sp/><sp/>Fedehub</highlight></codeline>
<codeline lineno="6"><highlight class="normal">:Version:</highlight></codeline>
<codeline lineno="7"><highlight class="normal"><sp/><sp/><sp/><sp/>1.0</highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal">About<sp/>the<sp/>node<sp/></highlight></codeline>
<codeline lineno="10"><highlight class="normal">---------------</highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal">It<sp/>implements<sp/>a<sp/><ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref><sp/>machine<sp/><ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref><sp/>controls<sp/>the<sp/>operations<sp/>of<sp/>the<sp/>robot;<sp/>it<sp/><ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref><sp/>the<sp/>core<sp/>node<sp/>of<sp/>the<sp/>architecture<sp/><ref refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" kindref="member">that</ref><sp/>interacts<sp/>with<sp/>and<sp/>directs<sp/>all<sp/>remaining<sp/>parts</highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal">In<sp/><ref refid="_oracle_8rst_8txt_1a3d397519c2d9adf8283ffa3045d32aaf" kindref="member">particular</ref><sp/>the<sp/>machine<sp/>organises<sp/>the<sp/><ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref><sp/>into<sp/>**four**<sp/>states.</highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal">-<sp/>**move**<sp/>→<sp/>moves<sp/>the<sp/>robot<sp/>between<sp/><ref refid="_r_e_a_d_m_e_8md_8txt_1aca7722d4c280e5b446037c7231f98662" kindref="member">rooms</ref><sp/>inside<sp/>the<sp/>simulated<sp/>indoor<sp/><ref refid="_r_e_a_d_m_e_8md_8txt_1ab0dc513ee1cd7fe2bb426f5359186e76" kindref="member">environment</ref></highlight></codeline>
<codeline lineno="17"><highlight class="normal">-<sp/>**collect**<sp/>→<sp/>the<sp/>robot<sp/>rotates<sp/>on<sp/>itself<sp/>to<sp/>read<sp/>the<sp/>largest<sp/>number<sp/>of<sp/>hints<sp/>within<sp/>the<sp/>room</highlight></codeline>
<codeline lineno="18" refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" refkind="member"><highlight class="normal">-<sp/>**check**<sp/>→<sp/>takes<sp/>hints<sp/>from<sp/>the<sp/>sensing<sp/>system<sp/>via<sp/>a<sp/><ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref>,<sp/>and<sp/>uses<sp/>the<sp/>ontology<sp/>to<sp/>work<sp/>out<sp/>whether<sp/>there<sp/><ref refid="_state__machine_8rst_8txt_1ab33486ceadd7a3e45e246b2743118981" kindref="member">are</ref><sp/>possible<sp/><ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref><sp/>or<sp/>not.<sp/>If<sp/>there<sp/>occurs<sp/>no<sp/>possible<sp/><ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref>,<sp/>the<sp/><ref refid="namespacestate__machine_1acbf2f3b4f08f91ac415d0c496d674e03" kindref="member">outcome</ref><sp/><ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref><sp/><ref refid="_state__machine_8rst_8txt_1a7463cda555922b364d4d9285bc99f4e4" kindref="member">mistery_not_solvable</ref>,<sp/>and<sp/>the<sp/>robot<sp/><ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref><sp/>back<sp/>to<sp/>the<sp/></highlight><highlight class="stringliteral">&quot;move&quot;</highlight><highlight class="normal"><sp/><ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref>.<sp/><ref refid="_state__machine_8rst_8txt_1a5c4f7762ecc115173cd76d7536a61804" kindref="member">Otherwise</ref>,<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>there<sp/>actually<sp/>occurs<sp/>possible<sp/><ref refid="_state__machine_8rst_8txt_1abefde73421c9664340fcc4d23667d7cc" kindref="member">solutions</ref>,<sp/>the<sp/><ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref><sp/>machine<sp/>makes<sp/>a<sp/>transition<sp/>to<sp/>the<sp/></highlight><highlight class="stringliteral">&quot;show&quot;</highlight><highlight class="normal"><sp/><ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref>,<sp/>responsible<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>querying<sp/>the<sp/>oracle<sp/>about<sp/>the<sp/>solution</highlight><highlight class="stringliteral">&apos;s<sp/>truthfulness</highlight></codeline>
<codeline lineno="19"><highlight class="stringliteral">-<sp/>**show**<sp/>→<sp/>questions<sp/>the<sp/>oracle<sp/>about<sp/>the<sp/>solution</highlight></codeline>
<codeline lineno="20"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="21"><highlight class="stringliteral">..<sp/>image::<sp/>ExperimentalRoboticsAssignment3/media/state_diagrams/state_diagram.jpg</highlight></codeline>
<codeline lineno="22"><highlight class="stringliteral"><sp/><sp/>:width:<sp/>400</highlight></codeline>
<codeline lineno="23"><highlight class="stringliteral"><sp/><sp/>:alt:<sp/>state<sp/>machine<sp/>raw<sp/>representation</highlight></codeline>
<codeline lineno="24"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="25" refid="_state__machine_8rst_8txt_1a9b5199b4c81a0e3487465bc0a08a44ad" refkind="member"><highlight class="stringliteral">Therefore,<sp/>as<sp/>the<sp/>state_machine<sp/>gets<sp/>launched,<sp/>the<sp/>robot<sp/>enters<sp/>the<sp/>MOVE<sp/>state,<sp/>responsible<sp/>for<sp/>the<sp/>acrivation<sp/>of<sp/>the<sp/>``/go_to_point``<sp/>service.<sp/>Hence,<sp/>it<sp/>reaches<sp/>the<sp/>center<sp/>of<sp/>the<sp/>room<sp/>and<sp/>it<sp/>starts<sp/>to<sp/>collect<sp/>as<sp/>many<sp/>marker<sp/>as<sp/>possible.</highlight></codeline>
<codeline lineno="26" refid="_state__machine_8rst_8txt_1a0b536d100a54f87beeb088ead9e55ff2" refkind="member"><highlight class="stringliteral">This<sp/>has<sp/>been<sp/>made<sp/>possible<sp/>through<sp/>the<sp/>implementation<sp/>of<sp/>a<sp/>``/turn_robot``<sp/>service<sp/>that,<sp/>as<sp/>the<sp/>name<sp/>explicitly<sp/>suggests,<sp/>makes<sp/>detectibot<sp/>turning<sp/>around<sp/>its<sp/>own<sp/>position.<sp/>Only<sp/>after,<sp/>the<sp/>system<sp/>transitions<sp/>to<sp/>the<sp/>CHECK<sp/>state,<sp/>where<sp/>a<sp/>request<sp/>is<sp/>made<sp/>by<sp/>the<sp/>``/aruco_marker``<sp/>service<sp/>to<sp/>retrieve<sp/>the<sp/>detected<sp/>marker&apos;</highlight><highlight class="normal">s<sp/><ref refid="_state__machine_8rst_8txt_1ad09e3d9cbc01b152c2c1311a5a5950f0" kindref="member">IDs</ref><sp/>(by<sp/>means<sp/>of<sp/>a<sp/>topic<sp/>subscription).</highlight></codeline>
<codeline lineno="27"><highlight class="normal">Whenever<sp/>a<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/><ref refid="_oracle_8rst_8txt_1a31598fc9ace12f0c15d34780665fbcf9" kindref="member">hint</ref><sp/>gets<sp/>detected,<sp/>the<sp/>knowledge<sp/>base<sp/>represented<sp/>by<sp/>**<ref refid="namespacecluedo__kb" kindref="compound">cluedo_kb</ref>**<sp/>node<sp/><ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref><sp/><ref refid="_state__machine_8rst_8txt_1a2659887f46d0b471a57b5e07c4be95e6" kindref="member">issued</ref><sp/>(with<sp/>a<sp/>``/oracle_hint``<sp/><ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref><sp/>request).</highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal">By<sp/>means<sp/>of<sp/>a<sp/>further<sp/>request,<sp/>made<sp/>to<sp/>the<sp/>final_oracle<sp/>node<sp/>through<sp/>the<sp/>``/oracle_solution``<sp/><ref refid="_state__machine_8rst_8txt_1ad685c8ea8188e50a20227f8228e7f606" kindref="member">service</ref>,<sp/>the<sp/>True<sp/><ref refid="_oracle_8rst_8txt_1acc5905728f3f1ab997990f9b4ccaa13b" kindref="member">ID</ref><sp/>gets<sp/>compared<sp/>and<sp/>it<sp/><ref refid="_r_e_a_d_m_e_8md_8txt_1af1324d0bc77791472f5243eadcfb11b2" kindref="member">is</ref><sp/><ref refid="_img__echo_8rst_8txt_1af89959d671d8edcafe6635b166adec1a" kindref="member">chosen</ref><sp/>whether<sp/>to<sp/>terminate<sp/>the<sp/><ref refid="_state__machine_8rst_8txt_1a98ae9a1bfb617ab4f379f45fea176bfe" kindref="member">investigation</ref><sp/>(ending<sp/>up<sp/>in<sp/>a<sp/>MISTERY_SOLVED<sp/><ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref>)<sp/>or<sp/>pursuing<sp/>it,<sp/>transitioning<sp/>back<sp/>to<sp/>the<sp/>MOVE<sp/><ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref></highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight></codeline>
<codeline lineno="31"><highlight class="normal">Why<sp/>Smach?</highlight></codeline>
<codeline lineno="32"><highlight class="normal">------------</highlight></codeline>
<codeline lineno="33"><highlight class="normal">For<sp/>the<sp/><ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref><sp/>machine<sp/>SMACH<sp/>has<sp/>been<sp/>employed<sp/><sp/>since<sp/>it<sp/>was<sp/>needed<sp/>a<sp/>robot<sp/>capable<sp/>of<sp/>achieving<sp/>a<sp/>Plan<sp/>where<sp/>all<sp/>possible<sp/>states<sp/>and<sp/><ref refid="_state__machine_8rst_8txt_1ab29524ec61eb0a0afa9a3bf3bccaee93" kindref="member">state</ref><sp/><ref refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" kindref="member">transitions</ref><sp/>were<sp/>described<sp/>explicitly.<sp/></highlight></codeline>
<codeline lineno="34" refid="_state__machine_8rst_8txt_1a784e647f2b3eb81ad423541600c71ddb" refkind="member"><highlight class="normal">Some<sp/>of<sp/>the<sp/>most<sp/>relevant<sp/><ref refid="_state__machine_8rst_8txt_1a784e647f2b3eb81ad423541600c71ddb" kindref="member">aspects</ref>,<sp/>offered<sp/>by<sp/>such<sp/>a<sp/></highlight><highlight class="keyword">package<sp/></highlight><highlight class="normal">are:</highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal">-<sp/>**Fast<sp/>prototyping**:<sp/>The<sp/>straightforward<sp/>Python-based<sp/>SMACH<sp/>syntax<sp/>makes<sp/>it<sp/>easy<sp/>to<sp/>quickly<sp/>prototype<sp/>a<sp/>state<sp/>machine<sp/>and<sp/>start<sp/>running<sp/>it.</highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight></codeline>
<codeline lineno="38" refid="_state__machine_8rst_8txt_1af11e9ac7d4e83f3a1c9d027dd32ddbf1" refkind="member"><highlight class="normal">-<sp/>**Complex<sp/>state<sp/>machines:**<sp/>SMACH<sp/>allows<sp/>you<sp/>to<sp/>design,<sp/>maintain<sp/>and<sp/>debug<sp/>large,<sp/>complex<sp/>hierarchical<sp/>state<sp/>machines.<sp/>You<sp/>can<sp/>find<sp/>an<sp/>example<sp/>of<sp/>a<sp/>complex<sp/>hierarchical<sp/>state<sp/>machine<sp/>here.</highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight></codeline>
<codeline lineno="40" refid="_state__machine_8rst_8txt_1ad8f8ce1821d1acad67cfe572fd968fbe" refkind="member"><highlight class="normal">-<sp/>**Introspection:**<sp/>SMACH<sp/>gives<sp/>you<sp/>full<sp/>introspection<sp/>in<sp/>your<sp/>state<sp/>machines,<sp/>state<sp/>transitions,<sp/>data<sp/>flow,<sp/>etc.<sp/>See<sp/>the<sp/>smach_viewer<sp/>for<sp/>more<sp/>details.<sp/></highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal">Code<sp/>Reference</highlight></codeline>
<codeline lineno="44"><highlight class="normal">---------------</highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="normal">..<sp/>automodule::<sp/>state_machine</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/>:members:</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/>:noindex:</highlight></codeline>
    </programlisting>
    <location file="_build/html/_sources/code_documentation/State_machine.rst.txt"/>
  </compounddef>
</doxygen>
